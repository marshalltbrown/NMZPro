8

@Himal's answer is correct for the current question however you might want to amend this to use event_generate in the message generating code and have the UI respond to the events when they are raised rather than polling the queue like this. You can use root.event_generate('<<MessageQueued>>') in the generate_text fuction to place a virtual event onto Tk's event queue. This is thread safe where calling window methods directly is not. If you also add a binding to this virtual event on the UI code then the Tk message loop with call the bound function when it receives the virtual event. No more polling.

import tkinter as tk
import threading
import queue
import time

def generate_text(mainwin, storage):
    count = 0
    while True:
        message = "Item {}".format(count)
        storage.put(message)
        print("Queued {0}".format(message))
        count += 1
        mainwin.event_generate('<<MessageGenerated>>')
        time.sleep(3000/1000)

def process(storage, event):
    msg = storage.get()
    print("New message: {0}".format(msg))

def main():
    message_queue = queue.Queue()
    root = tk.Tk()
    root.bind('<<MessageGenerated>>', lambda e: process(message_queue, e))
    t = threading.Thread(target=generate_text, args=(root, message_queue,))
    t.setDaemon(True)
    t.start()
    root.mainloop()

if __name__ == '__main__':
    main()